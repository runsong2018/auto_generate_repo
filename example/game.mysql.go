// Code generated by auto_generate_repo.
// source:
//
// DO NOT EDIT

package repository

import (
	"context"
	"time"

	errors "github.com/rotisserie/eris"
	"gorm.io/datatypes"
	"gorm.io/gorm"
)

type GameQueryOption func(db *gorm.DB) *gorm.DB

type Game struct {
	Id               *int64          `json:"id,omitempty" gorm:"size:8;primaryKey"`
	Name             *string         `json:"name,omitempty"`
	Owners           *string         `json:"owners,omitempty"`
	NotificationList *string         `json:"notification_list,omitempty"`
	Description      *string         `json:"description,omitempty"`
	Attr             *datatypes.JSON `json:"attr,omitempty" gorm:"type:jsonb;default:'{}'"`
	CreatedBy        *string         `json:"created_by,omitempty" gorm:"size:100;comment:创建者"`
	CreatedAt        *time.Time      `json:"created_at,omitempty" gorm:"comment:创建时间"`
	ModifiedBy       *string         `json:"modified_by,omitempty" gorm:"size:100;comment:修改者"`
	ModifiedAt       *time.Time      `json:"modified_at,omitempty" gorm:"comment:修改时间"`
	DeletedAt        *time.Time      `json:"deleted_at,omitempty" gorm:"comment:删除时间"`
}

func (Game Game) TableName() string {
	return "game"
}

func (Game *Game) BuildQuery() GameQueryOption {
	g := Game
	return func(db *gorm.DB) *gorm.DB {
		db = db.Where(g)
		return db
	}
}

func (Game *Game) BuildFuzzyQuery() GameQueryOption {
	g := Game
	return func(db *gorm.DB) *gorm.DB {
		if g.Name != nil {
			db = db.Where("name like ?", "%"+*g.Name+"%")
		}
		if g.Description != nil {
			db = db.Where("description like ?", "%"+*g.Description+"%")
		}

		return db
	}
}

type defaultGameRepository struct {
	db *gorm.DB
}

func NewGameRepository(db *gorm.DB) GameRepository {
	return &defaultGameRepository{
		db: db,
	}
}

func (d *defaultGameRepository) CreateGame(ctx context.Context, data *Game) (err error) {
	if err := d.db.WithContext(ctx).Table(Game{}.TableName()).Create(data).Error; err != nil {
		return errors.Wrap(err, "failed to create Game entity")
	}
	return nil
}

func (d *defaultGameRepository) ListGames(ctx context.Context, options map[string]interface{}, query ...GameQueryOption) (data []*Game, err error) {
	exec := d.db.WithContext(ctx).Table(Game{}.TableName())
	for _, v := range query {
		exec = v(exec)
	}
	for key, val := range options {
		switch key {
		case "limit":
			exec = exec.Limit(val.(int))
		case "offset":
			exec = exec.Offset(val.(int))
		case "sort":
			exec = exec.Order(val).Order("id ASC")
		case "select":
			exec = exec.Select(val)
		}
	}

	err = exec.Find(&data).Error
	if err != nil {
		return data, errors.Wrap(err, "failed to list the Game entities")
	}
	return data, err
}

func (d *defaultGameRepository) GetGame(ctx context.Context, query *Game) (data *Game, err error) {
	data = &Game{}
	exec := d.db.WithContext(ctx).Table(Game{}.TableName())
	exec = exec.Where(query)
	err = exec.Last(data).Error
	if err != nil {
		return nil, errors.Wrap(err, "failed to get the Game")
	}
	return data, err
}

func (d *defaultGameRepository) UpdateGame(ctx context.Context, update, query *Game) (data *Game, err error) {
	exec := d.db.WithContext(ctx).Table(Game{}.TableName())
	exec = exec.Where(query)
	out := &Game{}
	result := exec.Updates(update)
	if result.Error != nil {
		return nil, errors.Wrap(err, "failed to update Game entity")
	}
	if result.RowsAffected == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	err = result.Row().Scan(
		&out.Id,
		&out.Name,
		&out.Owners,
		&out.NotificationList,
		&out.Description,
		&out.Attr,
		&out.CreatedBy,
		&out.CreatedAt,
		&out.ModifiedBy,
		&out.ModifiedAt,
		&out.DeletedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update Game entity")
	}

	return out, nil
}

func (d *defaultGameRepository) DeleteGame(ctx context.Context, query *Game) (err error) {
	exec := d.db.WithContext(ctx).Table(Game{}.TableName())
	exec = exec.Where(query).Delete(&Game{})
	err = exec.Error
	if err != nil {
		return errors.Wrap(err, "failed to delete the Game")
	}
	return nil
}

func (d *defaultGameRepository) DeleteGames(ctx context.Context, ids []any) (err error) {
	exec := d.db.WithContext(ctx).Table(Game{}.TableName())
	for _, v := range ids {
		exec = exec.Where("id <> ?", v)
	}
	err = exec.Delete(&Game{}).Error
	if err != nil {
		return errors.Wrap(err, "failed to delete the Games")
	}
	return nil
}

type GameRepository interface {
	CreateGame(ctx context.Context, data *Game) (err error)
	ListGames(ctx context.Context, options map[string]interface{}, query ...GameQueryOption) (data []*Game, err error)
	GetGame(ctx context.Context, query *Game) (data *Game, err error)
	UpdateGame(ctx context.Context, update, query *Game) (data *Game, err error)
	DeleteGame(ctx context.Context, query *Game) (err error)
	DeleteGames(ctx context.Context, ids []any) (err error)
}
