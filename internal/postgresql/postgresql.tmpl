// Code generated by auto_generate_repo.
// source:
//
// DO NOT EDIT

package {{.PackageName}}

import (
    "time"
	"context"

	"gorm.io/gorm"
	errors "github.com/rotisserie/eris"
    "github.com/jackc/pgx/v5/pgconn"
    {{- range .Fields }}
    {{- if eq .Type "datatypes.JSON" }}
    "gorm.io/datatypes"
    {{- end }}
    {{- end }}
)

type {{.Name}}QueryOption func(db *gorm.DB) *gorm.DB

type {{.Name}} struct {
    {{- range .Fields }}
    {{.Name}} *{{.Type}} `json:"{{.Name|SnakeString}},omitempty"{{- if ne .Gorm ""}} {{.Gorm}} {{- end}}` {{- if ne .Comment ""}} // {{.Comment}} {{- end}}
    {{- end }}
}

func (i {{.Name}}) TableName() string {
    return "{{.TableName}}"
}

func (g *{{.Name}}) BuildQuery() {{.Name}}QueryOption {
	return func(db *gorm.DB) *gorm.DB {
		db = db.Where(g)
		return db
	}
}

func (g *{{.Name}}) BuildFuzzyQuery() {{.Name}}QueryOption {
	return func(db *gorm.DB) *gorm.DB {
	    {{- range .Fields }}
	    {{- if eq .Option "fuzzy" }}
            if g.{{.Name}} != nil {
        		db = db.Where("{{.Name|SnakeString}} ilike ?", "%"+*g.{{.Name}}+"%")
        	}
        {{- end }}
	    {{- end }}

		return db
	}
}

type default{{.Name}}Repository struct {
    db *gorm.DB
}

func New{{.Name}}Repository(db *gorm.DB) {{.Name}}Repository {
	return &default{{.Name}}Repository{
		db: db,
	}
}

func (d *default{{.Name}}Repository) Create{{.Name}}(ctx context.Context, data *{{.Name}}) (err error) {
    var pgError *pgconn.PgError
	if err := d.db.WithContext(ctx).Table({{.Name}}{}.TableName()).Create(data).Error; err != nil {
		if errors.As(err, &pgError) && pgError.Code == PgErrUniqueViolation {
        	return errors.Wrap(gorm.ErrDuplicatedKey, pgError.Detail)
        }
        return errors.Wrap(err, "failed to create {{.Name}} entity")
	}
	return nil
}


func (d *default{{.Name}}Repository) List{{.Name}}s(ctx context.Context,  options map[string]interface{}, query ...{{.Name}}QueryOption) (data []*{{.Name}}, err error) {
    exec := d.db.WithContext(ctx).Table({{.Name}}{}.TableName())
	for _, v := range query {
    	exec = v(exec)
    }
	for key, val := range options {
		switch key {
		case "limit":
			exec = exec.Limit(val.(int))
		case "offset":
			exec = exec.Offset(val.(int))
		case "sort":
			exec = exec.Order(val).Order("id ASC")
		case "select":
			exec = exec.Select(val)
		}
	}

	err = exec.Find(&data).Error
    if err != nil {
		return data, errors.Wrap(err, "failed to list the {{.Name}} entities")
	}
	return data,err
}


func (d *default{{.Name}}Repository) Get{{.Name}}(ctx context.Context,  query *{{.Name}}) (data *{{.Name}}, err error) {
    data = &{{.Name}}{}
    exec := d.db.WithContext(ctx).Table({{.Name}}{}.TableName())
	exec = exec.Where(query)
	err = exec.Last(data).Error
    if err != nil {
		return nil, errors.Wrap(err, "failed to get the {{.Name}}")
	}
	return data, err
}

func (d *default{{.Name}}Repository) Update{{.Name}}(ctx context.Context,update, query *{{.Name}}) (data *{{.Name}},err error) {
	var pgError *pgconn.PgError
	exec := d.db.WithContext(ctx).Table({{.Name}}{}.TableName())
    exec = exec.Where(query)
	out := &{{.Name}}{}
	result := exec.Updates(update)
	if result.Error != nil {
		if errors.As(err, &pgError) && pgError.Code == PgErrUniqueViolation {
			return nil, errors.Wrap(gorm.ErrDuplicatedKey, pgError.Detail)
		}
		return nil, errors.Wrap(err, "failed to update {{.Name}} entity")
	}
	if result.RowsAffected == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	err = result.Row().Scan(
	{{- range $key,$value := .Fields }}
        &out.{{.Name}},
    {{- end }}
	)
	if err != nil {
		if err.Error() == ErrUpdateScanNoSql.Error() {
			return out, nil
		}
		return nil, errors.Wrap(err, "failed to update {{.Name}} entity")
	}

	return out, nil
}

type {{.Name}}Repository interface {
	Create{{.Name}}(ctx context.Context, data *{{.Name}}) (err error)
	List{{.Name}}s(ctx context.Context, options map[string]interface{}, query ...{{.Name}}QueryOption) (data []*{{.Name}},err error)
	Get{{.Name}}(ctx context.Context, query *{{.Name}}) (data *{{.Name}}, err error)
	Update{{.Name}}(ctx context.Context, update , query *{{.Name}}) (data *{{.Name}},err error)
}
